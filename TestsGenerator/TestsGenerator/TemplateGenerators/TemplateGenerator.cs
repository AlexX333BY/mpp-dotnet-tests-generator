using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;
using System;
using System.Collections.Generic;
using System.Linq;
using TestsGenerator.CodeAnalysis;
using TestsGenerator.DataStructures;

namespace TestsGenerator.TemplateGenerators
{
    public class TemplateGenerator : ITemplateGenerator
    {
        protected readonly ICodeAnalyzer codeAnalyzer;

        public IEnumerable<PathContentPair> Generate(string source)
        {
            if (source == null)
            {
                throw new ArgumentException("Source shouldn't be null");
            }

            List<PathContentPair> resultList = new List<PathContentPair>();
            
            TestFileInfo fileInfo = codeAnalyzer.Analyze(source);
            List<UsingDirectiveSyntax> commonUsings = fileInfo.Usings.Select((usingStr) => UsingDirective(IdentifierName(usingStr))).ToList();

            foreach (TestClassInfo typeInfo in fileInfo.Classes)
            {
                resultList.Add(new PathContentPair(typeInfo.Name + "Test.cs", CompilationUnit()
                    .WithUsings(
                        List<UsingDirectiveSyntax>(
                            CreateClassUsings(typeInfo, commonUsings)))
                    .WithMembers(
                        SingletonList<MemberDeclarationSyntax>(
                            CreateClassWithNamespaceDeclaration(typeInfo)))
                    .NormalizeWhitespace().ToFullString()));
            }

            return resultList;
        }

        protected UsingDirectiveSyntax[] CreateClassUsings(TestClassInfo typeInfo, List<UsingDirectiveSyntax> fileUsings)
        {
            return new List<UsingDirectiveSyntax>(fileUsings)
            {
                UsingDirective(IdentifierName(typeInfo.Namespace))
            }.ToArray();
        }

        protected MemberDeclarationSyntax CreateClassWithNamespaceDeclaration(TestClassInfo typeInfo)
        {
            return NamespaceDeclaration(
                IdentifierName(typeInfo.Namespace + ".Test"))
            .WithMembers(
                SingletonList<MemberDeclarationSyntax>(
                    CreateClassDeclaration(typeInfo)));
        }

        protected ClassDeclarationSyntax CreateClassDeclaration(TestClassInfo typeInfo)
        {
            return ClassDeclaration(typeInfo.Name + "Test")
            .WithAttributeLists(
                SingletonList<AttributeListSyntax>(
                    AttributeList(
                        SingletonSeparatedList<AttributeSyntax>(
                            Attribute(
                                IdentifierName("TestClass"))))))
            .WithModifiers(
                TokenList(
                    Token(SyntaxKind.PublicKeyword)))
            .WithMembers(
                List<MemberDeclarationSyntax>(
                    typeInfo.Methods.Select((methodInfo) => CreateMethodDeclaration(methodInfo)).ToArray()));
        }

        protected MethodDeclarationSyntax CreateMethodDeclaration(TestMethodInfo methodInfo)
        {
            return MethodDeclaration(
                PredefinedType(
                    Token(SyntaxKind.VoidKeyword)),
                Identifier(methodInfo.Name + "Test"))
            .WithAttributeLists(
                SingletonList<AttributeListSyntax>(
                    AttributeList(
                        SingletonSeparatedList<AttributeSyntax>(
                            Attribute(
                                IdentifierName("TestMethod"))))))
            .WithModifiers(
                TokenList(
                    Token(SyntaxKind.PublicKeyword)))
            .WithBody(
                Block(
                    SingletonList<StatementSyntax>(
                        ExpressionStatement(
                            InvocationExpression(
                                MemberAccessExpression(
                                    SyntaxKind.SimpleMemberAccessExpression,
                                    IdentifierName("Assert"),
                                    IdentifierName("Fail")))
                            .WithArgumentList(
                                ArgumentList(
                                    SingletonSeparatedList<ArgumentSyntax>(
                                        Argument(
                                            LiteralExpression(
                                                SyntaxKind.StringLiteralExpression,
                                                Literal("autogenerated"))))))))));
        }

        public TemplateGenerator(ICodeAnalyzer codeAnalyzer)
        {
            this.codeAnalyzer = codeAnalyzer ?? throw new ArgumentException("Code analyzer shouldn't be null");
        }
    }
}
